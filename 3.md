##通过**j**来操作列
###通过j来选择一列
```r
> DT[,V2]
[1]"A" "A" "A" "A" "B" "B" "B" "B" "C" "C" "C" "C"
```
注意到V2这一列是以向量的形式返回的
###通过j来选择多列
```r
> DT[,.(V2,V3)]
    V2      V3
 1:  A  0.3408
 2:  A -0.7460
 3:  A -0.3795
 4:  A -0.7033
 5:  B -0.7033
 6:  B  0.3408
 7:  B -0.7460
 8:  B -0.3795
 9:  C -0.3795
10:  C -0.7033
11:  C  0.3408
12:  C -0.7460
```
V2与V3这两列以data.table的形式返回

.()为list()的一个别名。如果使用.(),返回的为一个data.table对象。如果不使用.()，结果为返回一个向量。
###在j上调用函数
```r
> DT[,sum(V1)]
[1] 18
```
以向量的形式返回V1列中所有元素的总和
###在多列上进行计算
以data.table的形式，返回V1这列的所有元素之和与V3这列的标准差
```r
> DT[,.(sum(V1),sd(V3))]
   V1        V2
1: 18 0.4546055
```
###指定计算列的列名
类似上例，但有一个新的列名
```r
> DT[,.(Aggregate = sum(V1), Sd.V3 = sd(V3))]
   Aggregate     Sd.V3
1:        18 0.4546055
```
###若列的长度不一，则会循环对齐

选择V1这一列，并计算V3这列的标准差，将会得到一个标准差的值并循环补齐
```r
> DT[,.(V1, Sd.V3 = sd(V3))]
 V1     Sd.V3
 1:  1 0.4546055
 2:  2 0.4546055
 3:  1 0.4546055
 4:  2 0.4546055
 5:  2 0.4546055
 6:  1 0.4546055
 7:  2 0.4546055
 8:  1 0.4546055
 9:  1 0.4546055
10:  2 0.4546055
11:  1 0.4546055
12:  2 0.4546055
```
###多个表达式可以包裹在花括号中
输出V2这一列并绘制V3这一列
```r
> DT[,{print(V2)
plot(V3)
NULL}]
[1] "A" "A" "A" "A" "B" "B" "B" "B" "C" "C" "C" "C"
#And a plot
NULL
```
